

\chapter{Data Representation}


\section{Introducing Binary}



Here we introduce some non-standard notation. 
We use these \textit{Oxford Brackets} 
to show we are assigning a meaning to the binary digits. 
The \textit{natural} (unsigned) assignment is denoted by subscript $N$. 
Suppose we have a binary digits \textsf{x} and the unsigned we associate is $x$.
We write this as: $\llbracket \text{\textsf{x}} \rrbracket_{n} = x$
where the $n$ denotes a \textit{natural} interpretation of the binary. 

\highlightdef{\textbf{Number Table Series Expansion}: 
$\llbracket \text{\textsf{x}} \rrbracket_{n} = \sum^{T-1}_{t=0} 2^{t} \textsf{x}_t$}

This is the most natural way to assign an 
arithmetical value to this sequence of digits. 

\frmrule

Proof of uniqueness.

\frmrule



\section{Excess-n}

We write this as: $\llbracket \text{\textsf{x}} \rrbracket_{ex(n)} = x$

The definition of excess-n works backwards from the definition 
of $\llbracket \text{\textsf{x}} \rrbracket_{n}$. 
If we compare $\llbracket \text{\textsf{x}} \rrbracket_{n}$ 
to $\llbracket \text{\textsf{x}} \rrbracket_{ex(n)}$,
then $\llbracket \text{\textsf{x}} \rrbracket_{n}$, from the point of view 
of our new representation, is \textit{in excess} of $n$ 
(has an extra of $n$). Written as an equation, the definition is as follows.

\highlightdef{\textbf{Excess-n}: 
$\llbracket \text{\textsf{x}} \rrbracket_{n}  = 
\llbracket \text{\textsf{x}} \rrbracket_{ex(n)} + n$}

The value, $x$, that we want excess-n to give for binary \textsf{x} 
is $n$ too much when we use the natural representation. It's \textit{in excess}. 
And so, to find $\llbracket \text{\textsf{x}} \rrbracket_{ex(n)}$, 
we simply subtract $n$ from the natural representation. 

\frmrule 

\begin{example}
Find $\llbracket \text{\textsf{1011}} \rrbracket_{ex(8)}$.
\end{example}

\frameans{}{3}

The normal interpretation \textsf{x} has an excess of 8 (having an extra of 8) 
in comparison with the excess-8 interpretation. 
So if we subtract 8 from $\llbracket \text{\textsf{x}} \rrbracket_{n}$, 
we will find the $\llbracket \text{\textsf{x}} \rrbracket_{ex(8)}$


\section{One's Complement}


Prove that $x$ is a power of two iff $x \& (x-1) = 0$.


\section{Two's Complement}

We write this as: $\llbracket \text{\textsf{x}} \rrbracket_{2c} = x$




% TODO: fix render
\highlightdef{
\parbox[c][3.5em][c]{0.98\textwidth}{
\centering
\textbf{Two's Complement}: 
$ \llbracket \text{\textsf{x}} \rrbracket_{2c} = \left\{ 
  \begin{array}{ll}
    \llbracket \text{\textsf{x}} \rrbracket_{n} & 
    \quad \text{for} \quad 0 \leqslant \llbracket \text{\textsf{x}} \rrbracket_{n} < 2^{n-1}  \\
    \llbracket \text{\textsf{x}} \rrbracket_{n} - 2^{n} & 
    \quad \text{for} \quad 2^{n-1} \leqslant \llbracket \text{\textsf{x}} \rrbracket_{n} < 2^{n}
  \end{array} \right.$
}
}


\highlightdef{\textbf{Two's Complement Operation}: 
$\llbracket 2C(\text{\textsf{x}}) \rrbracket_{2c}  = 
- \llbracket \text{\textsf{x}} \rrbracket_{2c}$
}



\section{Ten's Complement}

We write this as: $\llbracket \text{\textsf{x}} \rrbracket_{10c} = x$


\section{Hexidecimal}


\section{General Base-n}

\highlightdef{\textbf{Number Table Series Expansion}: 
$\llbracket \text{\textsf{x}} \rrbracket_{r} = \sum^{N-1}_{t=0} r^{t} \textsf{x}_t$}


\frmrule 

\begin{example}
Data can be presented in Base-64. The digits used in base 64 consist of lowercase letters, 
uppercase letters and digits. Unfortunately, these along are not enough.
$26 + 26 + 10 = 62$, so we are short by two digits. Base64 chooses plus (+), 
and forward-slash (/) for the remaining two digits, although similar systems 
exist that choose different characters for the digits.
\end{example}


\frmrule 

\begin{example}
An IP address (to be precise, an IP\textit{v4} address) can be seen as a 
base 256 number with four digits. It's difficult to find 
255 different looking symbols, so we use (000,...,255) as our 256 digits, 
and separate them using dots. This is known 
as the \textit{dotted-decimal system}.
\end{example}


% div and mod

\highlightdef{
\textbf{Left} $n$ \textbf{Digits Extraction}: $x/R^{(M-n)}$ \\
\textbf{Right} $n$ \textbf{Digits Extraction}: $x\%R^n$ 
}

where $M = \ceil{\log_R(x)}$ is the maximum power used in the number table of $x$. Think of div as shifting right and 
mod as cleaning left. 




\highlightdef{$n$\textbf{th Digit Extraction}: $(x/R^n)\% R$ }
... where $R$ is the radix. 

\begin{example}
Show that $(x \% R^{n}) / R^{n-1}$ also performs nth digit 
extraction.  
\end{example}
So we can either shift-right then clean-left, or clean-left then shift-right. 

\begin{example}
Write an algorithm to verify if an integer is a palindrome using div and mod.
\end{example}

\begin{example}
Write an algorithm to reverse an integer using div and mod.
\end{example}

\begin{example}
Write an algorithm to detect neighbours in UVa 10067
\end{example}


\section{Base-n Groups}

% Apply to Unicode (same left digit extraction = same plane)
% Apply IP addresses subnetting (same right digit extraction = same subnet)
% Apply to direct mapped caches (same left digit extraction = same cache line)