
\chapter{Polymorphism}





\section{Java Dynamic Binding}


\section{C++ Dynamic Binding}


\section{C\# Dynamic Binding}


\begin{example}
Explain the difference between \lstinline{@Override} in Java and 
\lstinline{override} in C\#.

@Override creates a compile-time check that a method is being overridden.\\
It not only makes the compiler check but also documents the developer's intention.

\end{example} 




\section{Downcasting}



\highlightdef{\textbf{C++ Dynamic Cast}: Use C++ RTTI to downcast }

\section{Four Polymorphisms}

Christopher Strachey (1967) introduced the concept of polymorphism into programming languages 
by informally distinguishing functions that work differently on different argument types
uniformly on a range of argument types He defined the former as \textit{ad-hoc polymorphism}
and the latter as \textit{parametric polymorphism}:

Cardelli and Wegner (1985) expanded Strachey's distinction to accommodate object-oriented languages.  
He contrasted functions that work on finite set of different and potentially unrelated types
(coercion, overloading) with functions that work on a potentially infinite number of
types across some common structure (inclusion, parametric). 


Ad-hoc Polymorphism
\begin{itemize}   
\renewcommand{\labelitemi}{$\Box$}
\item \textbf{Coercion} Often called \textit{implicit/explicit casting}. Assume float $ < $ int $ < $ char. 
Then implicity conversions or \textit{coercions} between the three types can occur in languages like C++. 
Coercion may \textit{narrow} the argument type (upcast) widen the argument type (promotion, downcast). 
\item \textbf{Overloading} Using \textit{same} name to denote different tasks.
\end{itemize}

Universal Polymorphism
\begin{itemize}   
\renewcommand{\labelitemi}{$\Box$}
\item \textbf{Inclusion polymorphism} Also called \textit{Subtype polymorphism} 
or called \textit{Runtime polymorphism}. 
\item \textbf{Parametric polymorphism} Also known as \textit{compile-time polymorphism}.
C++ implements parametric polymorphism at compile-time using C++ templates. Java implements 
parametric polymorphism using generics.  Function and class definitions that share 
identical structure across an unlimited range of different types. 
\end{itemize}

\frmrule

\begin{example}
Below shows an example of coercion. 

\begin{lstlisting}
#include <iostream>
// One function definition:
void display(int a) const {
 std::cout << "One argument (" << a << ')'; 
}

int main() {
 display(10);
 std::cout << std::endl;
 display(12.6); // narrowing
 std::cout << std::endl;
 display('\n'); // widening
 std::cout << std::endl;
}
\end{lstlisting}
\end{example}

If we assume float $ < $ int $ < $ char, then the second call to display is an implicit up cast to int 
(a narrowing). The third call to display is an implicit down-cast from char to float (a widening). 

\frmrule

The previous example of coercion involved implicit converion. 
The follow example demonstrates that we classify some explicit conversions as coercion. 

\frmrule


\section{Dependencies}



\section{Dependency Inversion}