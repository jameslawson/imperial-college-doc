
\chapter{Design Patterns I}


\section{Observer Pattern}

Used when objects need to be notified of changes in
another object. The object that is listening implements an
interface containing a callback function that is invoked when
a change occurs.

\section{Iterator Pattern}

Provides a method to traverse an aggregate data
structure while abstracting away assumptions about that
data structure.


\section{Strategy Pattern}

Strategy pattern enables different algorithms get selected at run-time. 
In this case, by passing different Comparator, different algorithms can get selected. 
Based on the example above and now assuming you have another 
Comparator which compares Dogs by weight instead of by size, 
you can simply create a new Comparator like the following.

\begin{lstlisting}
class Dog{
	int size;
	int weight;
 
	public Dog(int s, int w){
		size = s;
		weight = w; 
	}
}
 
class DogSizeComparator implements Comparator<Dog>{
 
	@Override
	public int compare(Dog o1, Dog o2) {
		return o1.size - o2.size;
	}
}
 
class DogWeightComparator implements Comparator<Dog>{
 
	@Override
	public int compare(Dog o1, Dog o2) {
		return o1.weight - o2.weight;
	}
}
 
public class ArraySort {
 
	public static void main(String[] args) {
		Dog d1 = new Dog(2, 50);
		Dog d2 = new Dog(1, 30);
		Dog d3 = new Dog(3, 40);
 
		Dog[] dogArray = {d1, d2, d3};
		printDogs(dogArray);
 
		Arrays.sort(dogArray, new DogSizeComparator());	
		printDogs(dogArray);
 
		Arrays.sort(dogArray, new DogWeightComparator());	
		printDogs(dogArray);
	}
 
	public static void printDogs(Dog[] dogs){
		for(Dog d: dogs)
			System.out.print("size="+d.size + " weight=" + d.weight + " ");
 
		System.out.println();
	}
}
\end{lstlisting}



\section{State Pattern}


