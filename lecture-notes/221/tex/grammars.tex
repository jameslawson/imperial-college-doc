
\chapter{Parsing I: Grammars}


\section{Term Rewriting Systems}

\section{Context Free Grammars}



A context-free grammar (CFG) is a set of \textit{rewriting rules}. 
used to generate patterns of strings. 
We give the formal definition. 

A \textit{context-free grammar} is a tuple $(N,T,R,S)$ 
where 
\begin{itemize}
\item \textbf{Non-terminals} $N$. These are usually denote by uppercase letters.
A non-terminal will eventually be rewritten to zero or more \textit{terminal character}. 
This rewriting is based on the \textit{rewrite rules}. 
\item \textbf{Terminals} $T$. These are usually denote by lowercase letters.
Terminals are the final result of rewriting non-terminals. Terminals can be rewritten no further. 
They are the output characters of the CFG. 
\item \textbf{Rewrite Rules} $R$. A set of rewrite rules of the form $A \rightarrow \alpha$ where 
$A$ is a non-terminal from $N$, and $\alpha$ is sequence of zero or more symbols from $(N \cup \Sigma)^{*}$. 
\item \textbf{Starting Non-terminal} $S$. We choose a non-terminal from $N$ to \textit{start from}.
\end{itemize}

\frmrule 

\begin{example}
Here we give an example of a CFG and explain how this follows from the formal definition.
Let $G = (\{E\},\{a,b\},\{E \rightarrow aEb, E \rightarrow ab\}, E)$. 

\end{example}

\frmrule 

\highlightdef{
$\alpha, \beta, \gamma,...$: zero or more terminals and nonterminals\\
$A,B,C,D,E,...,X,Y,Z$: terminals\\
$a,b,c,d,e,....$: non-terminals
}


\frmrule 

Quite often the formal notation is a bit too verbose. 
There are much shorter ways to give a CFG. 
There are various notations for context free grammars. 
If the left hand sides are the same then we can combine 
the rules into one list. A given left hand side 
gives an list of possible right-hand sides (we use $|$ to denote or). 

Shorthands:
Provide only the productions. All lhs symbols comprise N
All other sysmbols comprise T. lhs of first production is S


\highlightdef{Each rewrite rule gives a tree of choices.}




\begin{example}
$E' \rightarrow E$;
$E \rightarrow T \text{+} E | T$;
$T \rightarrow F \times T | F$;
$F \rightarrow D | \text{(} E \text{)}$;
$D \rightarrow \text{0} | \text{1} | \dotsm | \text{9}$;
\end{example}

We do a \textit{left factorisation}. 
Each alternative can start with the same thing. 

An expression can start with a term.
A term can start with a factor.


$E' \rightarrow E$;
$E \rightarrow T (\text{+} E | \epsilon)$;
$T \rightarrow F (\times T | \epsilon)$;
$F \rightarrow D | \text{(} E \text{)}$;
$D \rightarrow \text{0} | \text{1} | \dotsm | \text{9}$;




\section{Recursion}



\highlightdef{CFGs can capture recursion}

When we make recursive calls in programming languages, 
each call has arguments provided. 
However in CFGs, the there are no arguments provided. 
Each recursive call \textit{has no context}. 







\section{Ambiguity}

\highlightdef{\textbf{Ambiguity}: A CFG $G$ is \textit{ambiguous} iff  
there exists an $x \in L(G)$ st $S \Rightarrow x$ where }

That is a CFG is \textit{ambiguous} if there is more than one 
parse tree for some sentences $\alpha \in L(G)$.

\highlightdef{It is impossible to check whether a CFG is ambiguous}

Formally this concept is called \textit{undecidability}. 
We say that this problem is \textit{undecidable}. 

Although it is impossible for a computer to check, 
as Humans we can use intuition and reasonning for small 
examples to decide/show that a given CFG is ambiguous.





%URI            = absoluteURI [ "#" fragment ]
%absoluteURI    = scheme ":" *( uchar | reserved )
%uchar          = unreserved | escape
%unreserved     = ALPHA | DIGIT | safe | extra | national
%escape         = "%" HEX HEX
%reserved       = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+"
%extra          = "!" | "*" | "'" | "(" | ")" | ","
%safe           = "$" | "-" | "_" | "."
%unsafe         = CTL | SP | <"> | "#" | "%" | "<" | ">"
%national       = RFC 1945                        HTTP/1.0     








% \highlightdef{\textbf{Epsilon First Set}: }

\frmrule 

